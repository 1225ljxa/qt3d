/****************************************************************************
**
** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/
**
** This file is part of the Qt3D documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms
** and conditions contained in a signed written agreement between you
** and Nokia.
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \title Writing a scene format plug-in for Qt3D
    \keyword Scene Format Plugin
    \example sceneformats/obj

    \section1 Plugin architecture for scene formats to be deprecated.

    In the original design for Qt3D we considered loading of different
    file formats to be analagous to loading different image formats, and
    thus it was written following the pattern of the libpng, and libtiff
    format that exists in QtBase.  This meant scanning the plugins
    directory for a sceneformat loader plugin that supported the given
    file type, and if one was found loading that and then reading the file.

    However this is a poor match for the actual job and slows down the
    loading of assets as the loader has to resolve a plugin before it can
    actually start loading the asset.

    With the support provided by Asset Importer a wide array of scene
    formats is supported, and it makes most sense for new formats that
    are not currently supported to be added and upstreamed to Asset
    Importer.

    Another consideration for the deprecation process is that our
    QML bindings depend on a structured scene format.  Scene-nodes,
    materials and effects must be included in the scene using a set and
    known schema.  With the original plug-in API the idea was that plugins
    would be free to do any kind of rendering or representation and thus
    this schema is not able to be supported.  This means that plugins
    would be created that could not be rendered or would be buggy and
    inconsistent in QML.

    With upcoming support for animations this problem becomes even more
    pressing since animations formats in asset files must also be exposed
    to our QML bindings.

    The QGLAbstractScene class will stay, possibly with some modifications
    but the plug-in apparatus will be dismantled and thus loading of
    assets via a plugin architecture will removed in favour of a direct
    loading functionality, probably kept in a seperate library linked
    at compile time.  This should mean smaller code, faster loading and
    better support for animations and future functionality.

    The bezier plugin will be retained and we will look at contributing
    it to Asset Importer if the format is general enough.

    Since deprecation of the sceneformat plugin API is a considerable change
    to our API's we will not do it lightly.  So far however we have had no
    contributions to the sceneformats and no-one has asked about it, or used
    it, despite this tutorial existing.  At present it will be marked
    \bold deprecated and in our next release cycle it will be removed
    altogether.

    \section1 Sceneformat Tutorial
    Scene format plugins are used to load external 3D model file
    formats like \bold 3DS, \bold obj, and so on.  In this tutorial we will
    do a walk-through of the \bold obj scene format plugin to
    demonstrate what is required to add a new format to Qt3D.

    Models are loaded by QGLAbstractScene::loadScene(), which locates
    a suitable plug-in for the format, and then asks the plug-in to
    parse the data and create a QGLAbstractScene object that describes
    the 3D objects in the scene.

    We start by declaring an instance of QGLSceneFormatPlugin and
    arranging for it to be registered with the Qt plug-in system:

    \snippet ../../esceneformats/obj/main.cpp 1
    \snippet sceneformats/obj/main.cpp 4

    The two functions we need to implement are
    \l{QGLSceneFormatPlugin::keys()}{keys()} and
    \l{QGLSceneFormatPlugin::create()}{create()}.  The first of these
    returns a lower-case list of the file extensions and MIME types
    that are supported by the plug-in:

    \snippet sceneformats/obj/main.cpp 2

    The create function is called to create the QGLSceneFormatHandler
    which is used to load the model data:

    \snippet sceneformats/obj/main.cpp 3

    The create function is passed the QIODevice for the data,
    the URL of where the data was found, and the chosen format.
    These parameters can be used by the plug-in to decide which
    handler to return if multiple formats are supported by
    the plug-in.  In the case of obj, we always return the same
    handler so we don't need to inspect the passed parameters.

    QGLAbstractScene::loadScene() will set the parameters on
    the QGLSceneFormatHandler object and then call
    \l{QGLSceneFormatHandler::read()}{read()}:

    \snippet sceneformats/obj/qglobjscenehandler.h 1
    \dots
    \snippet sceneformats/obj/qglobjscenehandler.h 2

    The read function will typically construct a QGLBuilder
    for the geometry in the scene and then parse all of the objects,
    materials, textures, and so on.  Ultimately, it needs to produce a
    QGLAbstractScene object, populated with QGLSceneNode instances
    for each of the objects in the model file.  In our case, we create
    an instance of \c QGLObjScene:

    \snippet sceneformats/obj/qglobjscene.h 1
    \dots
    \snippet sceneformats/obj/qglobjscene.h 2
    \dots
    \snippet sceneformats/obj/qglobjscene.h 3

    The most important function is the override for
    QGLAbstractScene::objects(), which allows the rest of Qt3D
    to query the full list of objects in the model file.
    The scene object can also override QGLAbstractScene::object()
    if it has an efficient method to quickly look up an object by name.

    The scene should also override QGLAbstractScene::mainNode()
    to return the main mesh node in the scene.  Usually this is
    the first element in the list returned by QGLAbstractScene::objects()
    but doesn't have to be.

    Note: the plug-in does not need to use QGLBuilder and the
    other Qt3D classes to load the model if it doesn't want to.
    It can instantiate subclasses of QGLSceneNode that override
    the draw() method and draws the object using whatever technique
    the plug-in chooses.  It just needs to leave the OpenGL state
    in the condition that it found it so that other parts of Qt3D
    will not be confused.

    Once you have written a plug-in for your new format, you should
    install it into \c{$QTDIR/plugins/sceneformats}.  You can test it
    by running the \c{modelviewer} program and trying to load models
    in your new format.  When debugging, it can be useful to set the
    \c{QT_DEBUG_PLUGINS} environment variable to 1.

    \l{qt3d-examples.html}{Return to the main Tutorials page}.
*/
